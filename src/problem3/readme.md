## **Specific Issues with Code**

### 1. **`getPriority` Inside `useMemo`**

- **Where:** The `getPriority` function is defined inside the `useMemo` hook in the `sortedBalances` computation.
- **Why It's a Problem:** It gets recreated every time `sortedBalances` is recalculated, negating the performance benefits of `useMemo`.
- **Solution:** Move `getPriority` outside `useMemo` so it remains constant across renders.

### 2. **Inefficient Filtering and Sorting**

- **Where:** `balances.filter` and `.sort` are chained together in `useMemo` for `sortedBalances`.
- **Why It's a Problem:** Both operations have different complexities (`filter` is \(O(n)\), and `sort` is \(O(n \log n)\)). Executing them together repeatedly on every dependency change (e.g., `balances`, `prices`) is wasteful.
- **Solution:** Perform filtering first to reduce the dataset, then sort only the relevant items.

### 3. **Logical Errors in Filtering**

- **Where:** The filter checks for `balance.amount <= 0` and `getPriority(balance.blockchain) > -99`, but the conditions are inconsistent and error-prone (e.g., `lhsPriority` is undefined).
- **Why It's a Problem:** This can cause runtime errors or unexpected behavior.
- **Solution:** Rewrite the filter condition logically and clearly, ensuring proper variable usage.

### 4. **Separate Mapping for Formatting**

- **Where:** `sortedBalances` is created first, and then `formattedBalances` is generated by mapping over it.
- **Why It's a Problem:** Performing an additional `map` is unnecessary when formatting can be included in the initial transformation step.
- **Solution:** Combine formatting and sorting into a single step.

### 5. **Repeated Usage of `prices[balance.currency]`**

- **Where:** The USD value is computed repeatedly in the `rows` map step.
- **Why It's a Problem:** Accessing `prices[balance.currency]` multiple times within the same computation is inefficient.
- **Solution:** Calculate the USD value once during the transformation step and reuse it.

**Refactor Explanation:**
Previously, prices[balance.currency] might have been accessed multiple times in separate operations (e.g., during mapping or in the JSX rendering). In this refactored code:

The usdValue is calculated in the map method as part of the transformation process.
The result is stored in the usdValue field of the FormattedWalletBalance object.
Later, this pre-computed value (usdValue) is reused directly in the rows mapping.
This eliminates redundant lookups of prices[balance.currency] during subsequent processing, ensuring computational efficiency and cleaner code.

### 6. **Index as Key in `WalletRow`**

- **Where:** The `rows` map uses the array index (`key={index}`).
- **Why It's a Problem:** React relies on `key` for reconciliation. Using `index` can lead to bugs when the list order changes dynamically.
- **Solution:** Use a unique property like `balance.currency` as the `key`.
